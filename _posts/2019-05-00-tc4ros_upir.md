---
layout: post
title: "Trace Compass + ROS"
date: 2019-05-00
excerpt: "An overview of my project on Trace Compass & ROS"
tags: [Trace Compass, ROS, tracing, analysis, UPIR]
comments: false
---

## Introduction

This section will introduce both ROS and Trace Compass for people who have used only one (or none) of them. I will also talk about robotics and tracing in general.

### Context

#### ROS

[Robot Operating System (ROS)](http://www.ros.org/) is an open-source framework and a set of libraries and tools for robotics software development. Although it's sometimes called a "meta-OS," it's not really an OS.

Its main feature is probably the implementation of the publish-subscribe pattern. Nodes, which are "processes" designed to accomplish a specific task, can publish on, or subscribe to, one or more topics and send/receive messages. By launching multiple nodes (either from your own package or from a package someone else made), you can accomplish complex tasks!

#### Trace Compass

[Trace Compass](http://tracecompass.org) is a [trace](https://en.wikipedia.org/wiki/Tracing_(software)) viewer and analysis framework. It supports many trace formats, and provides numerous useful analyses/views out of the box, like the kernel resources and control flow views. Users can also use its API to implement their own analyses, which is what I did!

### Topic/goal

My initial goal was to look into where ROS development could benefit from tracing (and subsequent analyses) and try to help with that.

I considered targeting ROS 2, however, as it was still relatively new and less mature than ROS 1, I went with the latter.

### Literature review & existing solutions

A presentation at ROSCon 2017, titled ["Determinism in ROS -- or when things break /sometimes/ and how to fix it..."](https://vimeo.com/236186712) exposed how ROS' design does not guarantee determinism in execution.

<!-- more papers/presentation? -->

Many tools are distributed along with ROS to help users or developers. [`rqt_graph`](http://wiki.ros.org/rqt_graph) can create a graph of publisher/subscriber relations between nodes. It can also show publishing frequencies. Similarly, the ROS CLI tools (e.g. `rostopic`) can help debug basic pub/sub issues.

The [`diagnostics` package](http://wiki.ros.org/diagnostics) can collect diagnostics data for analysis.

The [`performance_test` package](https://github.com/apexai/performance_test) for ROS 2 can test the performance of a communications middleware.

However, all of the tools or solutions mentioned above cannot provide a view of the actual execution. Besides, the performance overhead of using higher-level log aggregators (e.g. as a ROS node) is probably greater than using tracing.

## Message flow analysis

### Motive

<!-- critical path analysis is useful.. 
https://github.com/tuxology/tracevizlab/tree/master/labs/102-tracing-wget-critical-path
-->

Time is one of the main concerns when building an application, e.g. execution time for a request or total execution time.

### Approach

#### Prereqs


#### How

In this sub-section, I'll go over some implementation details.

<!-- tracetools, important tracepoints -->


## Results/example

<!-- test cases, execution example, screenshots -->



## Conclusion



## Future work



## Acknowledgements

This project was done as part of the [UPIR](https://www.polymtl.ca/aide-financiere/bourses/bourses-upir-unite-de-participation-et-dinitiation-la-recherche) program at Polytechnique Montr√©al. My project, which was done over two trimesters, was supervised by Michel Dagenais, whom I thank for his great input.

I would also like to thank the Trace Compass team at Ericsson for 