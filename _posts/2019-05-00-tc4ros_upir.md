---
layout: post
title: "Trace Compass + ROS"
date: 2019-05-00
excerpt: "An overview of my project on Trace Compass & ROS"
tags: [Trace Compass, ROS, tracing, analysis, UPIR]
comments: false
---

## Introduction

Robotics software development can benefit from tracing and the low-overhead analyses it can provide. The overall goal of this project was to first look into where ROS could benefit from such analyses, and then work towards that.

This first section will introduce both ROS and Trace Compass for people who have used only one (or none) of them. I will also talk about robotics and tracing in general. The second and third sections will present my work along with some examples.

Finally, I will conclude and briefly talk about possible future work related to this project.

### Context

#### ROS

[Robot Operating System (ROS)](http://www.ros.org/) is an open-source framework and a set of libraries and tools for robotics software development. Although it has "Operating System" in its name, it's not really an OS!

Its main feature is probably the implementation of the publish-subscribe pattern. Nodes, which are "processes" designed to accomplish a specific task, can publish on, or subscribe to, one or more topics and send/receive messages. By launching multiple nodes (either from your own package or from a package someone else made), you can accomplish complex tasks!

#### Trace Compass

[Trace Compass](http://tracecompass.org) is an open source [trace](https://en.wikipedia.org/wiki/Tracing_(software)) viewer and analysis framework designed to solve performance issues. It supports many trace formats, and provides numerous useful analyses & views out of the box, such as the kernel resources and control flow views. Users can also use its API to implement their own analyses, which is what I did!

### Topic/goal

My initial goal was to look into where ROS development could benefit from tracing and subsequent analyses, and try to help with that.

Early on in this project, I considered targeting ROS 2. However, as it was still relatively new and less mature than ROS 1, I went with the latter.

### Literature review & existing solutions

A presentation at ROSCon 2017, titled ["Determinism in ROS -- or when things break /sometimes/ and how to fix it..."](https://vimeo.com/236186712) exposed how ROS' design does not guarantee determinism in execution. This is actually what piqued my curiosity at first, since I was a ROS user and had started to learn about tracing, and it eventually led to this project.

In this case, lack of determinism can be seen as merely a symptom. This led me to search for possible causes, one of which might be network/communications [1][2][3][4][5]. For latencies, which might lead to lack of determinism, critical path analyses can help identify the actual root cause [6][7][8][9].

As for tools, many are distributed along with ROS to help users and developers. [`rqt_graph`](http://wiki.ros.org/rqt_graph) can create a graph of publisher/subscriber relations between nodes. It can also show publishing rates. Similarly, the ROS CLI tools (e.g. `rostopic`) can help debug basic pub/sub issues.

Other tools are available. The [`diagnostics` package](http://wiki.ros.org/diagnostics) can collect diagnostics data for analysis. The [`performance_test` package](https://github.com/apexai/performance_test) for ROS 2 can test the performance of a communications middleware.

However, all of the tools or solutions mentioned above cannot provide a view of the actual execution. Besides, the performance overhead of using higher-level log aggregators (e.g. as a ROS node) is non-negligible.

The [`tracetools` package](https://github.com/bosch-robotics-cr/tracetools) enables ROS tracing along with the instrumentation. However, it does not offer analysis tools.

Trace Compass offers a [control flow view](https://github.com/tuxology/tracevizlab/tree/master/labs/101-trace-navigation-in-tracecompass), showing the state of threads over time. By selecting one particular thread, a user can launch a [critical path analysis](https://github.com/tuxology/tracevizlab/tree/master/labs/102-tracing-wget-critical-path).

## Message flow analysis

### Motive and goal

As mentioned previously, time is one of the main concerns for robotics applications. Critical path analyses can make these anomalies stand out and help developers find the root cause.

My goal was therefore to make a ROS-specific analysis along these lines. I chose to build what I call a "message flow analysis." Using `tracetools` and the ROS instrumentation, we can figure out which queues a message went through, how much time it spent in each one, and if it ended up being dropped. Also, by linking a message received by a subscriber to the next corresponding message that gets published by the same node, we can build a model of the message processing pipeline.

### Approach

#### Prereqs

To build this analysis, some information is needed on:

* connections between nodes
* subscriber/publisher queue states
* network packet exchanges

We first need to know about connections between nodes. The ROS instrumentation includes a tracepoint for new connections. It includes the address and port of the host and the destination, with an address:port pair corresponding to a specific publisher or subscription.

We also need to build a model of the publisher and subscriber queues. To achieve this, we can leverage the relevant tracepoints. These include a tracepoint for when a message is added to the queue, when it's dropped from the queue, and when it leaves the queue (either sent over the network to the subscriber, or given to callback(s)). We can therefore visualize the state of a queue over time.

Finally, we need information on network packet exchanges. Although this isn't really necessary for this kind of analysis, it allows us to link a message that gets published to a message that gets received by the subscriber with more confidence. This is good when building a robust analysis, and it paves the way for making a critical path analysis based on this message flow analysis.

This requires us to trace both userspace (ROS) and kernel. Fortunately, we only have to enable 2 kernel events for this, which saves us a lot of memory!

#### How

In this sub-section, I'll quickly go over some implementation details.

<!-- tracetools, important tracepoints -->
<!-- mention how models are built, then used -->

<!-- mention this, when appropriate -->
In ROS 1, a node is a process by itself, thus trace events can easily be attributed to the right node by using its PID.


## Results/example

<!-- test cases, execution example, screenshots -->



## Conclusion



## Future work



## Acknowledgements

This project was done as part of the [UPIR](https://www.polymtl.ca/aide-financiere/bourses/bourses-upir-unite-de-participation-et-dinitiation-la-recherche) program at Polytechnique Montréal. My project, which was done over two trimesters, was supervised by Michel Dagenais, whom I thank for his great input.

I would also like to thank the Trace Compass team at Ericsson for

## Links

<!-- include links to repos and doc on how to install TC and use incubator -->

## References

[1] C. S. V. Gutiérrez, L. U. S. Juan, I. Z. Ugarte, and V. M. Vilches, “Real-time Linux communications: an evaluation of the Linux communication stack for real-time robotic applications,” arXiv:1808.10821 [cs], Aug. 2018.  
[2] C. S. V. Gutiérrez, L. U. S. Juan, I. Z. Ugarte, I. M. Goenaga, L. A. Kirschgens, and V. M. Vilches, “Time Synchronization in modular collaborative robots,” arXiv:1809.07295 [cs], Sep. 2018.  
[3] C. S. V. Gutiérrez, L. U. S. Juan, I. Z. Ugarte, and V. M. Vilches, “Time-Sensitive Networking for robotics,” arXiv:1804.07643 [cs], Apr. 2018.  
[4] C. S. V. Gutiérrez, L. U. S. Juan, I. Z. Ugarte, and V. M. Vilches, “Towards a distributed and real-time framework for robots: Evaluation of ROS 2.0 communications for real-time robotic applications,” arXiv:1809.02595 [cs], Sep. 2018.  
[5] Y.-P. Wang, W. Tan, X.-Q. Hu, D. Manocha, and S.-M. Hu, “TZC: Efficient Inter-Process Communication for Robotics Middleware with Partial Serialization,” arXiv:1810.00556 [cs], Oct. 2018.  
[6] F. Giraldeau and M. Dagenais, “Wait Analysis of Distributed Systems Using Kernel Tracing,” IEEE Transactions on Parallel and Distributed Systems, vol. 27, no. 8, pp. 2450–2461, Aug. 2016.  
[7] F. Doray and M. Dagenais, “Diagnosing Performance Variations by Comparing Multi-Level Execution Traces,” IEEE Transactions on Parallel and Distributed Systems, pp. 1–1, 2016.  
[8] P.-M. Fournier and M. R. Dagenais, “Analyzing blocking to debug performance problems on multi-core systems,” ACM SIGOPS Operating Systems Review, vol. 44, no. 2, p. 77, Apr. 2010.  
[9] C.-Q. Yang and B. P. Miller, “Critical path analysis for the execution of parallel and distributed programs,” in [1988] Proceedings. The 8th International Conference on Distributed, San Jose, CA, USA, 1988, pp. 366–373.  
